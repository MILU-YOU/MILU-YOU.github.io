<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>当Dr.know照进现实——ChatGPT初体验</title>
      <link href="/2023/02/11/%E5%BD%93Dr-know%E7%85%A7%E8%BF%9B%E7%8E%B0%E5%AE%9E%E2%80%94%E2%80%94ChatGPT%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
      <url>/2023/02/11/%E5%BD%93Dr-know%E7%85%A7%E8%BF%9B%E7%8E%B0%E5%AE%9E%E2%80%94%E2%80%94ChatGPT%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<p>最近ChatGPT挺火的，本着要与时俱进，接触前沿科技的想法，毅然决定亲自去试试这东西，看看到底有没有传的那么<del>邪门</del>神奇。</p><h2 id="1-初闻chatGPT"><a href="#1-初闻chatGPT" class="headerlink" title="1.初闻chatGPT"></a>1.初闻chatGPT</h2><p>其实初次了解到ChatGPT的时候我脑海里最先闪过的是小时候看过的一部电影————《人工智能》里的万事通博士，也就是封面上的那位看起来很眼熟的白发老爷爷。万事通博士在影片中的设定就是无所不知，全年无休的知识速知中心。他会在每次登场时说道：“尽管问吧，我无所不知”。</p><p>知识速知中心这点倒是和“有问题找百度”的百度基本类似，但是与百度不同的便是这个“尽管问吧”，ChatGPT与万事通博士一样，可以像与人对话一样用自然语言进行发问与回答，并且还可以根据上下文进行一个完整的，连续的对话。</p><div align="center">    <img src="https://pic.imgdb.cn/item/63e7aac14757feff3394a225.png" width="40%"></div><blockquote><p><em>比较有意思的一点是，影片中向万事通博士提问是需要付费的，“五块两问，赠送一问”，而且乔吐槽他“很滑头，很会捞钱”。指的是万事通博士可能会将你不是提问的对话当成一个问题，或者选的提问分类不够精确的话可能会回答一个你不想要的答案。希望ChatGPT以后不会变成这样吧hhh</em></p></blockquote><h2 id="2-初次使用ChatGPT"><a href="#2-初次使用ChatGPT" class="headerlink" title="2.初次使用ChatGPT"></a>2.初次使用ChatGPT</h2><p>也没费多大功夫吧，区区几个小时和1美金而已(这高墙，我真是…)，顺利进入chatGPT使用界面。先问了一些网上都搜得到的基础问题，比如“什么是chatGPT”，“什么是人工智能”什么的。然后也试着像网上之前看到的，用一些修饰词来改进描述，比如请更详细，或者更通俗的方式描述，总之都回答的挺好的。</p><p>然后就试着问一些更抽象的问题，比如“如何证明1+1&#x3D;2”，或者“如何评价游戏原神”。回答的只能说有好有坏，像第一个问题他虽然说了这是一条基本公是，并列举了刻度还有苹果的例子来说明，但是整段内容总是很生硬得转到“所以1+1&#x3D;2”，并没有解释的很清楚。第二个问题他倒是一来就直截了当地说自己是一个非偏向性的ai，不能告诉我他的看法，只能向我介绍这款游戏。</p><p>最后就让他尝试写更难的文章长段落或者代码编写，整体表现还是挺惊艳的，代码的编写很详尽，甚至还有注释，最后还贴心的在代码最后加了类似请在实际业务中进行修改的字段。</p><h2 id="3-总结与展望"><a href="#3-总结与展望" class="headerlink" title="3.总结与展望"></a>3.总结与展望</h2><p>每当看到ChatGPT的光标在闪烁了几秒后开始一排排地敲出大段大段的文字去解释你的任何问题，内心总是会有一些震惊。个人认为目前chatGPT的功能已经有了相当的实用性，如果继续完善并朝可视化方面发展，说不定哪一天Dr.know真的会成为现实。</p><div align="center">    <img src="https://pic.imgdb.cn/item/63e7aab64757feff33942e9a.jpg" width="40%"></div><blockquote><p><em>写这篇文章之前我还特意请教了一下ChatGPT sennsei</em></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ChatGPT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在SpringBoot中获取application.properties内的值的三种方法</title>
      <link href="/2023/02/04/%E5%9C%A8SpringBoot%E4%B8%AD%E8%8E%B7%E5%8F%96application-properties%E5%86%85%E7%9A%84%E5%80%BC%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
      <url>/2023/02/04/%E5%9C%A8SpringBoot%E4%B8%AD%E8%8E%B7%E5%8F%96application-properties%E5%86%85%E7%9A%84%E5%80%BC%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文链接：<a href="https://blog.csdn.net/eqmaster/article/details/109485120">https://blog.csdn.net/eqmaster/article/details/109485120</a><br>仅用于个人学习，侵删</p></blockquote><p>三种获取方法：</p><blockquote><ol><li>通过Environment对象获取</li><li>通过@ConfigurationProperties注解获取</li><li>使用@Value注解</li></ol></blockquote><h2 id="1-通过Environment获取"><a href="#1-通过Environment获取" class="headerlink" title="1.通过Environment获取"></a>1.通过Environment获取</h2><p>在Controller 或者 Service 类中,使用@Autowired注解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private Environment env;</span><br></pre></td></tr></table></figure><p>使用getProperty(String key)获取具体的属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String keyValue = env.getProperty(key);</span><br></pre></td></tr></table></figure><p>比如在application.properties文件中存储如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.title=Learning Spring Boot </span><br><span class="line">app.description=Working with properties file</span><br></pre></td></tr></table></figure><p>在Controller中的使用示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package com.xarhsoft.properties;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.core.env.Environment;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;app&quot;)</span><br><span class="line">public class AppController &#123;</span><br><span class="line"> </span><br><span class="line"> @Autowired</span><br><span class="line"> private Environment env;</span><br><span class="line"> </span><br><span class="line"> @GetMapping(&quot;/property&quot;)</span><br><span class="line"> public String getPropertyValue(@RequestParam(&quot;key&quot;) String key)</span><br><span class="line"> &#123;</span><br><span class="line">  String returnValue = &quot;No value&quot;;</span><br><span class="line">  </span><br><span class="line">  //获取具体的属性</span><br><span class="line">  String keyValue = env.getProperty(key);</span><br><span class="line">  </span><br><span class="line">  if( keyValue!= null &amp;&amp; !keyValue.isEmpty())</span><br><span class="line">  &#123;</span><br><span class="line">   returnValue = keyValue;</span><br><span class="line">  &#125;</span><br><span class="line">  return returnValue;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-使用-Value注解"><a href="#2-使用-Value注解" class="headerlink" title="2.使用@Value注解"></a>2.使用@Value注解</h2><p>使用@Value(“${app.title}”)直接获取：<br>如获取如下内容中的第一行属性值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.title=Learning Spring Boot </span><br><span class="line">app.description=Working with properties file</span><br></pre></td></tr></table></figure><p>获取方法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;$&#123;app.title&#125;&quot;)</span><br><span class="line">private String appTitle;</span><br></pre></td></tr></table></figure><p>完整示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package com.xarhsoft.properties;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.beans.factory.annotation.Value;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;app&quot;)</span><br><span class="line">    </span><br><span class="line"> //此处获取到值</span><br><span class="line"> @Value(&quot;$&#123;app.title&#125;&quot;)</span><br><span class="line"> private String appTitle;</span><br><span class="line"> </span><br><span class="line"> @GetMapping(&quot;/value&quot;)</span><br><span class="line"> public String getValue()</span><br><span class="line"> &#123;</span><br><span class="line">  return appTitle;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-使用-ConfigurationProperties注解"><a href="#3-使用-ConfigurationProperties注解" class="headerlink" title="3.使用@ConfigurationProperties注解"></a>3.使用@ConfigurationProperties注解</h2><p>前例中定义的properties每个属性名称都以app前缀开头，所以我们需要用以下代码注解Java Bean：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@ConfigurationProperties(&quot;app&quot;)</span><br></pre></td></tr></table></figure><p>完整示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package com.xarhsoft.properties;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">@ConfigurationProperties(&quot;app&quot;)</span><br><span class="line">public class AppProperties &#123;</span><br><span class="line"> </span><br><span class="line"> private String title;</span><br><span class="line"> private String description;</span><br><span class="line"> public String getTitle() &#123;</span><br><span class="line">  return title;</span><br><span class="line"> &#125;</span><br><span class="line"> public void setTitle(String title) &#123;</span><br><span class="line">  this.title = title;</span><br><span class="line"> &#125;</span><br><span class="line"> public String getDescription() &#123;</span><br><span class="line">  return description;</span><br><span class="line"> &#125;</span><br><span class="line"> public void setDescription(String description) &#123;</span><br><span class="line">  this.description = description;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦有了AppProperties类的实例，就可以使用getter获取存储在application.properties文件中的属性的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package com.xarhsoft.properties;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.beans.factory.annotation.Value;</span><br><span class="line">import org.springframework.core.env.Environment;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;app&quot;)</span><br><span class="line">public class AppController &#123;</span><br><span class="line"></span><br><span class="line"> @Autowired</span><br><span class="line"> AppProperties myAppProperties;</span><br><span class="line"> </span><br><span class="line"> @GetMapping(&quot;/title&quot;)</span><br><span class="line"> public String getAppTitle()</span><br><span class="line"> &#123;</span><br><span class="line">  return myAppProperties.getTitle();</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> @GetMapping(&quot;/description&quot;)</span><br><span class="line"> public String getAppDescription()</span><br><span class="line"> &#123;</span><br><span class="line">  return myAppProperties.getDescription();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis常用标签</title>
      <link href="/2023/02/03/Mybatis%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"/>
      <url>/2023/02/03/Mybatis%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/</url>
      
        <content type="html"><![CDATA[<p>做项目时遇到的，以前学过但是又忘了，在此巩固一下</p><h2 id="1-lt-sql-gt-标签"><a href="#1-lt-sql-gt-标签" class="headerlink" title="1.&lt;sql&gt;标签"></a>1.&lt;sql&gt;标签</h2><p>重复的SQL预计永远不可避免，标签就是用来解决这个问题的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;sql id=&quot;sql1&quot;&gt;id,name,age,gender&lt;/sql&gt;</span><br><span class="line"></span><br><span class="line">&lt;select id=&quot;getPerson&quot; parameterType=&quot;int&quot; resultType=&quot;orm.Person&quot;&gt;</span><br><span class="line">    select </span><br><span class="line">    &lt;include refid=&quot;sql1&quot;&gt;&lt;/include&gt;</span><br><span class="line">     from Person where id=#&#123;id&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>&lt; sql &gt;:定义重复代码</p><p>id：sql代码块的名称</p><p>&lt; include &gt;：引用sql代码</p><p>refid:需要应用sql代码块的id</p><h2 id="2-lt-if-gt-和-lt-where-gt-标签"><a href="#2-lt-if-gt-和-lt-where-gt-标签" class="headerlink" title="2.&lt;if&gt;和&lt;where&gt;标签"></a>2.&lt;if&gt;和&lt;where&gt;标签</h2><p>查询sql语句:</p><blockquote><p>SELECT id, username, birthday, sex, address FROM <code>user</code> WHERE sex &#x3D; 1 AND username LIKE ‘%张%’</p></blockquote><p>mybatis动态sql：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 根据条件查询用户 --&gt;</span><br><span class="line">&lt;select id=&quot;queryUserByWhere&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&gt;</span><br><span class="line">SELECT id, username, birthday, sex, address FROM `user`</span><br><span class="line">&lt;!-- where标签可以自动添加where，同时处理sql语句中第一个and关键字 --&gt;</span><br><span class="line">&lt;where&gt;</span><br><span class="line">&lt;if test=&quot;sex != null&quot;&gt;</span><br><span class="line">AND sex = #&#123;sex&#125;</span><br><span class="line">&lt;/if&gt;</span><br><span class="line">&lt;if test=&quot;username != null and username != &#x27;&#x27;&quot;&gt;</span><br><span class="line">AND username LIKE</span><br><span class="line">&#x27;%$&#123;username&#125;%&#x27;</span><br><span class="line">&lt;/if&gt;</span><br><span class="line">&lt;/where&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><h2 id="3-lt-foreach-gt-标签"><a href="#3-lt-foreach-gt-标签" class="headerlink" title="3.&lt;foreach&gt;标签"></a>3.&lt;foreach&gt;标签</h2><p>Mybatis foreach 标签用于循环语句，它很好的支持了数据和 List、set 接口的集合，并对此提供遍历的功能。语法格式如下。</p><blockquote><p>&lt;foreach item&#x3D;”item” index&#x3D;”index” collection&#x3D;”list|array|map key” open&#x3D;”(“ separator&#x3D;”,” close&#x3D;”)”&gt;<br>    参数值<br>&lt;&#x2F;foreach&gt;</p></blockquote><p>foreach 标签主要有以下属性，说明如下。</p><ul><li>item：表示集合中每一个元素进行迭代时的别名。</li><li>index：指定一个名字，表示在迭代过程中每次迭代到的位置。</li><li>open：表示该语句以什么开始（既然是 in 条件语句，所以必然以(开始）。</li><li>separator：表示在每次进行迭代之间以什么符号作为分隔符（既然是 in 条件语句，所以必然以,作为分隔符）。</li><li>close：表示该语句以什么结束（既然是 in 条件语句，所以必然以)开始）。</li></ul><p>使用 foreach 标签时，最关键、最容易出错的是 collection 属性，该属性是必选的，但在不同情况下该属性的值是不一样的，主要有以下 3 种情况：</p><ul><li>如果传入的是单参数且参数类型是一个 List，collection 属性值为 list。</li><li>如果传入的是单参数且参数类型是一个 array 数组，collection 的属性值为 array。</li><li>如果传入的参数是多个，需要把它们封装成一个 Map，当然单参数也可以封装成 Map。Map 的 key 是参数名，collection 属性值是传入的 List 或 array 对象在自己封装的 Map 中的 key。</li></ul><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;selectWebsite&quot;</span><br><span class="line">    parameterType=&quot;net.biancheng.po.Website&quot;</span><br><span class="line">    resultType=&quot;net.biancheng.po.Website&quot;&gt;</span><br><span class="line">    SELECT id,name,url,age,country</span><br><span class="line">    FROM website WHERE age in</span><br><span class="line">    &lt;foreach item=&quot;age&quot; index=&quot;index&quot; collection=&quot;list&quot; open=&quot;(&quot;</span><br><span class="line">        separator=&quot;,&quot; close=&quot;)&quot;&gt;</span><br><span class="line">        #&#123;age&#125;</span><br><span class="line">    &lt;/foreach&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RESTful风格知识巩固</title>
      <link href="/2023/02/02/RESTful%E9%A3%8E%E6%A0%BC%E7%9F%A5%E8%AF%86%E5%B7%A9%E5%9B%BA/"/>
      <url>/2023/02/02/RESTful%E9%A3%8E%E6%A0%BC%E7%9F%A5%E8%AF%86%E5%B7%A9%E5%9B%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是API"><a href="#1-什么是API" class="headerlink" title="1.什么是API"></a>1.什么是API</h2><p>API，英文全称Application Programming Interface，翻译为“应用程序编程接口”。就是将一些功能（逻辑）封装成组件，目的是提供一个应用程序接口给其它程序与开发人员访问，而这些访问人员不需要访问源码以及理解内部工作原理就可以直接使用。</p><h2 id="2-前后端分离模式"><a href="#2-前后端分离模式" class="headerlink" title="2.前后端分离模式"></a>2.前后端分离模式</h2><p>指的是在开发阶段，前后端开发人员只需要约定好数据交互的接口，即可并行开发与测试。前端开发完可以独自进行mock测试，后端也可以使用postman等接口测试工具进行测试。最后可进行功能联调测试。</p><h2 id="3-RESTful风格"><a href="#3-RESTful风格" class="headerlink" title="3.RESTful风格"></a>3.RESTful风格</h2><h3 id="3-1-概念"><a href="#3-1-概念" class="headerlink" title="3.1 概念"></a>3.1 概念</h3><p>RESTFUL是一种网络应用程序的设计风格和开发方式，基于HTTP，可以使用 XML 格式定义或 JSON 格式定义。最常用的数据格式是JSON。由于<strong>JSON能直接被JavaScript读取</strong>，所以，<strong>使用JSON格式的REST风格的API具有简单、易读、易用的特点</strong>。</p><h3 id="3-2-资源"><a href="#3-2-资源" class="headerlink" title="3.2 资源"></a>3.2 资源</h3><p>REST 是面向资源的，每个资源都有一个唯一的<strong>资源定位符（URI）</strong>。每个URI代表一种资源（resource），所以URI中不能有动词，只能有名词，而且所用的名词往往与数据库的表名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以URI中的名词也应该使用复数。</p><h3 id="3-3-请求方式"><a href="#3-3-请求方式" class="headerlink" title="3.3 请求方式"></a>3.3 请求方式</h3><table><thead><tr><th>请求方式</th><th>含义</th></tr></thead><tbody><tr><td>GET（SELECT）</td><td>从服务器取出资源（一项或多项）</td></tr><tr><td>POST（CREATE）</td><td>在服务器新建一个资源</td></tr><tr><td>PUT（UPDATE）</td><td>在服务器更新资源（更新完整资源）</td></tr><tr><td>PATCH（UPDATE）</td><td>在服务器更新资源， PATCH更新个别属性</td></tr><tr><td>DELETE（DELETE）</td><td>从服务器删除资源</td></tr></tbody></table><hr><p>一句话描述REST实质：</p><blockquote><p><strong>URL中只使用名词来定位资源，用HTTP协议里的动词（GET、POST、PUT、DELETE）来实现资源的增删改查操作。</strong></p></blockquote><h2 id="4-getMapping、postMapping和requestMapping区别"><a href="#4-getMapping、postMapping和requestMapping区别" class="headerlink" title="4.getMapping、postMapping和requestMapping区别"></a>4.getMapping、postMapping和requestMapping区别</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(method = RequestMethod.GET)</span><br></pre></td></tr></table></figure><p>@GetMapping就是@RequestMapping附加了get请求方法<br>@PostMapping同理如上，就是附加了post请求方法</p><p><strong>什么时候使用</strong></p><ul><li><p>前端method中特指了get或post的时候分别使用@GetMapping和@PostMapping</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 示例</span><br><span class="line">&lt;form action=&quot;testGetMapping&quot; method=&quot;get&quot;&gt;这里使用@GetMapping&lt;form/&gt;</span><br><span class="line">&lt;form action=&quot;testPostMapping&quot; method=&quot;post&quot;&gt;这里使用@PostMapping&lt;form/&gt;</span><br></pre></td></tr></table></figure></li><li><p>如果传的参数是@RequestBody ，多参或者传对象的情况下使用@PostMapping注解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;/getOrderList&quot;)</span><br><span class="line">public List&lt;Object&gt; getList(@RequestBody List&lt;Object&gt; orderList) &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>无参，@RequestParam和@PathVaiable的情况下使用GetMapping</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@gettMapping(&quot;/test&quot;)</span><br><span class="line">public ModelAndView test16(@RequestParam(&quot;id&quot;)Long id)&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@gettMapping(&quot;/test/&#123;id&#125;&quot;)</span><br><span class="line">public  ModelAndView (@PathVaiable(&quot;name&quot;) Long id)&#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-RequestParam、-PathVariable、-RequestBody的用法与区别"><a href="#5-RequestParam、-PathVariable、-RequestBody的用法与区别" class="headerlink" title="5.@RequestParam、@PathVariable、@RequestBody的用法与区别"></a>5.@RequestParam、@PathVariable、@RequestBody的用法与区别</h2><h3 id="5-1-PathVariable"><a href="#5-1-PathVariable" class="headerlink" title="5.1 @PathVariable"></a>5.1 @PathVariable</h3><blockquote><p>URL变量</p></blockquote><p>Web应用中的URL通常不是一成不变的，例如微博两个不同用户的个人主页对应两个不同的URL：<a href="http://weibo.com/user1">http://weibo.com/user1</a> 和<a href="http://weibo.com/user2%E3%80%82">http://weibo.com/user2。</a> 我们不能对于每一个用户都编写一个被@RequestMapping注解的方法来处理其请求，也就是说，对于相同模式的URL（例如不同用户的主页，他们仅仅是URL中的某一部分不同，为他们各自的用户名，我们说他们具有相同的模式）。</p><p>可以在@RequestMapping注解中用{ }来表明它的变量部分，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(value=&quot;/user/&#123;username&#125;&quot;)</span><br></pre></td></tr></table></figure><p>这里的{username}就是我们定义的变量规则，username是变量的名字，那么这个URL路由可以匹配下列任意URL并进行处理：</p><ul><li>&#x2F;user&#x2F;Tom</li><li>&#x2F;user&#x2F;Jerry</li><li>&#x2F;user&#x2F;Jack2</li></ul><p>在路由中定义变量规则后，通常我们需要在处理方法（也就是@RequestMapping注解的方法）中获取这个URL的具体值，并根据这个值（例如用户名）做相应的操作，SpringMVC提供的@PathVariable可以帮助我们:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(value=&quot;/user/&#123;username&#125;&quot;)</span><br><span class="line">    public String userProfile(@PathVariable(value=&quot;username&quot;) String username) &#123;</span><br><span class="line">    return &quot;user&quot;+username;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-RequestParam"><a href="#5-2-RequestParam" class="headerlink" title="5.2 @RequestParam"></a>5.2 @RequestParam</h3><blockquote><p>Request参数</p></blockquote><p> 在访问各种各样的网站时，经常会发现网站的URL的最后一部分形如：?xx&#x3D;yy&amp;zz&#x3D;ww。这就是HTTP协议中的Request参数，它有什么用呢？先看一个例子：</p><ul><li>在知乎中搜索web<br> 浏览器跳转到新页面后，URL变为<a href="https://www.zhihu.com/search?type=content&amp;q=web">https://www.zhihu.com/search?type=content&amp;q=web</a></li><li>在知乎中搜索java<br> 浏览器跳转到新页面后，URL变为<a href="https://www.zhihu.com/search?type=content&amp;q=java">https://www.zhihu.com/search?type=content&amp;q=java</a></li></ul><p>这里的type&#x3D;content&amp;q&#x3D;web就是搜索请求的参数，不同参数之间用&amp;分隔，每个参数形如name&#x3D;value的形式，分别表示参数名字和参数值。在这个例子中，我们输入不同的搜索关键词，在搜索结果页面的URL的q参数是不同的。也就是说，HTTP参数实际上可以认为是一种用户的输入，根据不同的用户输入，服务器经过处理后返回不同的输出（例如搜索spring和搜索java，显示结果是不一样的）</p><p> 在SpringMVC框架中，可以通过定义@RequestMapping来处理URL请求。和@PathVariable一样，需要在处理URL的函数中获取URL中的参数，也就是?key1&#x3D;value1&amp;key2&#x3D;value2这样的参数列表。通过注解@RequestParam可以轻松地将URL中的参数绑定到处理函数方法的变量中：<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(value=&quot;/user&quot;)</span><br><span class="line">public String getUserBlog(@RequestParam(value=&quot;id&quot;) int blogId) &#123;</span><br><span class="line">return &quot;blogId=&quot;+blogId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="5-3-RequestBody"><a href="#5-3-RequestBody" class="headerlink" title="5.3 @RequestBody"></a>5.3 @RequestBody</h3><blockquote><p>@RequestBody 主要用来接收前端传递给后端的 json 字符串中的数据(请求体中的数据)</p></blockquote><p> 例如:<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//异步请求部分代码</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">　　　　　　　　url:&quot;/hello&quot;,</span><br><span class="line">　　　　　　　　type:&quot;POST&quot;,</span><br><span class="line">　　　　　　　　data:&#x27;&#123;&quot;id&quot;:&quot;123&quot;,&quot;name&quot;:&quot;chenyc&quot;&#125;&#x27;,</span><br><span class="line">　　　　　　　　content-type:&quot;application/json charset=utf-8&quot;,</span><br><span class="line">　　　　　　　　success:function(data)&#123;</span><br><span class="line">　　　　　　　　　　alert(data);</span><br><span class="line">　　　　　　　　&#125;</span><br><span class="line">　　　　&#125;);</span><br></pre></td></tr></table></figure></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//@requestBody注解获取数据代码</span><br><span class="line">@requestMapping(&quot;/hello&quot;)</span><br><span class="line">　　　　public String hello(@requestBody Integer id,@requestBody String name)&#123;</span><br><span class="line">　　　　　　System.out.println(&quot;id:&quot;+id+&quot;;&quot;+&quot;name:&quot;+name);</span><br><span class="line">　　　　&#125;</span><br></pre></td></tr></table></figure><p>此时@requestBody注解就可以获取到请求中的各个参数然后赋值到相对应的方法形参上，另外，当有一个实体类User包含了id和name的元素的话，在方法里面直接可以写@requestBody User user就会自动封装好给我们使用的了</p>]]></content>
      
      
      <categories>
          
          <category> 学习相关 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Swagger3的集成及使用</title>
      <link href="/2023/01/20/Swagger3%E7%9A%84%E9%9B%86%E6%88%90%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/01/20/Swagger3%E7%9A%84%E9%9B%86%E6%88%90%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Swagger相关介绍"><a href="#1-Swagger相关介绍" class="headerlink" title="1.Swagger相关介绍"></a>1.Swagger相关介绍</h2><p>前后端分离的项目，接口文档的存在十分重要。与手动编写接口文档不同，<strong>swagger是一个用于生成、描述和调用 RESTful 接口的 Web 服务。</strong> 通俗来讲就是可以自动生成接口文档并测试调用相关接口。</p><p>Swagger2已经在17年停止维护了，取而代之的是 sagger3，与 swagger2 相比新版的swagger3 配置更少，使用更加方便。</p><p>如果想要将 Swagger 文档集成到 Spring 中，目前有两个开源项目可供开发者选择，一个是 SpringFox，另一个是 SpringDoc，这两个项目都是由 Spring 社区来维护的，在 Swagger 2.0 时代，SpringFox 是主流，但是随着 Swagger 3.0 版本发布之后，SpringDoc 对最新版本的兼容性更好，而且 SpringDoc 支持 Swagger 页面 Oauth2 登录，因此使用 SpringDoc 是更好的选择。</p><h2 id="2-集成步骤"><a href="#2-集成步骤" class="headerlink" title="2.集成步骤"></a>2.集成步骤</h2><h3 id="①向pom-xml文件中添加如下依赖"><a href="#①向pom-xml文件中添加如下依赖" class="headerlink" title="①向pom.xml文件中添加如下依赖"></a>①向pom.xml文件中添加如下依赖</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springdoc&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springdoc-openapi-ui&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.5.4&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="②书写配置类"><a href="#②书写配置类" class="headerlink" title="②书写配置类"></a>②书写配置类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class OpenApiConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public OpenAPI qiwenFileOpenAPI() &#123;</span><br><span class="line">        return new OpenAPI()</span><br><span class="line">                .info(new Info().title(&quot;网盘项目 API&quot;)</span><br><span class="line">                        .description(&quot;基于springboot + vue 框架开发的Web文件系统，旨在为用户提供一个简单、方便的文件存储方案，能够以完善的目录结构体系，对文件进行管理 。&quot;)</span><br><span class="line">                        .version(&quot;v1.0.0&quot;)</span><br><span class="line">                        .license(new License().name(&quot;MIT&quot;).url(&quot;http://springdoc.org&quot;)))</span><br><span class="line">                .externalDocs(new ExternalDocumentation()</span><br><span class="line">                        .description(&quot;网盘gitee地址&quot;)</span><br><span class="line">                        .url(&quot;https://www.gitee.com/qiwen-cloud/qiwen-file&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="③在代码中添加相应接口的注解描述"><a href="#③在代码中添加相应接口的注解描述" class="headerlink" title="③在代码中添加相应接口的注解描述"></a>③在代码中添加相应接口的注解描述</h3><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Tag(name = &quot;user&quot;, description = &quot;该接口为用户接口，主要做用户登录，注册和校验token&quot;)</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/user&quot;)</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    @Operation(summary = &quot;用户注册&quot;, description = &quot;注册账号&quot;, tags = &#123;&quot;user&quot;&#125;)</span><br><span class="line">    @PostMapping(value = &quot;/register&quot;)</span><br><span class="line">    public RestResult&lt;String&gt; addUser(@RequestBody RegisterDTO registerDTO) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="④访问Swagger"><a href="#④访问Swagger" class="headerlink" title="④访问Swagger"></a>④访问Swagger</h3><p>启动项目后，在浏览器中访问如下地址即可:</p><blockquote><p>localhost:8080&#x2F;swagger-ui&#x2F;</p></blockquote><p>显示效果如下:<br><img src="https://pic.imgdb.cn/item/63db903aac6ef86016bbbe25.png" alt="swagger3"></p><h2 id="3-注解介绍"><a href="#3-注解介绍" class="headerlink" title="3.注解介绍"></a>3.注解介绍</h2><p><strong>@Tag注解</strong><br>该注解可以用在类或方法上，当作用在方法是用来定义单个操作，当作用在类上代表所有操作。</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>name</td><td>标签名</td></tr><tr><td>description</td><td>这里可以做一个简短的描述</td></tr><tr><td>externalDocs</td><td>添加一个扩展文档</td></tr><tr><td>extensions</td><td>可选的扩展列表</td></tr></tbody></table><p><strong>@Operation注解</strong><br>该注解可用于将资源方法定义为 OpenAPI 操作，在该注解中也可以定义该操作的其他属性。</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>method</td><td>HTTP 请求方法</td></tr><tr><td>tags</td><td>按照资源对操作进行逻辑分组</td></tr><tr><td>summary</td><td>提供此操作的简要说明</td></tr><tr><td>description</td><td>对操作的详细描述</td></tr><tr><td>requestBody</td><td>与操作关联的请求报文</td></tr><tr><td>parameters</td><td>一个可选的参数数组</td></tr><tr><td>responses</td><td>执行此操作返回的可能响应的列表</td></tr><tr><td>deprecated</td><td>允许将操作标记为已弃用</td></tr><tr><td>security</td><td>可用于此操作的安全机制的声明</td></tr></tbody></table><p><strong>@Schema注解</strong><br>该注解用来定义模型，主要用来定义模型类及模型的属性，请求和响应的内容、报文头等。</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>not</td><td>提供用于禁止匹配属性的 java 类</td></tr><tr><td>name</td><td>用于描述模型类或属性的名称</td></tr><tr><td>title</td><td>用于描述模型类的标题</td></tr><tr><td>maximum</td><td>设置属性的最大数值</td></tr><tr><td>minimum</td><td>设置属性的最小数值</td></tr><tr><td>maxLength</td><td>设置字符串值的最大长度</td></tr><tr><td>minLength</td><td>设置字符串值的最大小度</td></tr><tr><td>pattern</td><td>值必须满足的模式</td></tr><tr><td>required</td><td>是否必需输入</td></tr><tr><td>description</td><td>描述</td></tr><tr><td>nullable</td><td>如果为 true 则可能为 null</td></tr><tr><td>example</td><td>使用示例</td></tr></tbody></table><hr><p><strong>swagger3与swagger2的注解对应关系为:</strong></p><table><thead><tr><th>swagger2</th><th>OpenAPI 3</th><th>注解位置</th></tr></thead><tbody><tr><td>@Api</td><td>@Tag(name &#x3D; “接口类描述”)</td><td>Controller 类上</td></tr><tr><td>@ApiOperation</td><td>@Operation(summary &#x3D;“接口方法描述”)</td><td>Controller 方法上</td></tr><tr><td>@ApiImplicitParams</td><td>@Parameters</td><td>Controller 方法上</td></tr><tr><td>@ApiImplicitParam</td><td>@Parameter(description&#x3D;“参数描述”)</td><td>Controller 方法上 @Parameters 里</td></tr><tr><td>@ApiParam</td><td>@Parameter(description&#x3D;“参数描述”)</td><td>Controller 方法的参数上</td></tr><tr><td>@ApiIgnore</td><td>@Parameter(hidden &#x3D; true) 或 @Operation(hidden &#x3D; true) 或 @Hidden</td><td>-</td></tr><tr><td>@ApiModel</td><td>@Schema</td><td>DTO类上</td></tr><tr><td>@ApiModelProperty</td><td>@Schema</td><td>DTO属性上</td></tr></tbody></table><p>至此整个文档在开发过程已经满足日常使用的要求，但是整体文档风格及排版不太符合大多数人的视觉体验，甚至有人觉得它丑，这个因人而异，因此下面将介绍另一款工具 knife4j，来美化该文档。</p><h2 id="4-集成knife4j美化文档"><a href="#4-集成knife4j美化文档" class="headerlink" title="4.集成knife4j美化文档"></a>4.集成knife4j美化文档</h2><p>knife4j 在最新版本已经基本完全兼容了 springdoc-openapi-ui，因此在替换的时候将依赖替换掉就可以了，打开 pom.xml 文件，删除掉之前的 springdoc-openapi-ui 依赖，添加如下依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.0.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>替换完成之后，重新启动项目，在地址栏之后添加 <strong>&#x2F;doc.html</strong> 即可访问文档。</p><p>然后在配置文件中将先前的配置类改为如下配置完善文档描述信息:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class OpenApiConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean(value = &quot;indexApi&quot;)</span><br><span class="line">    public Docket indexApi() &#123;</span><br><span class="line">        return new Docket(DocumentationType.OAS_30)</span><br><span class="line">                .groupName(&quot;网站前端接口分组&quot;).apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(&quot;team.zlg.file.controller&quot;))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ApiInfo apiInfo() &#123;</span><br><span class="line">        return new ApiInfoBuilder()</span><br><span class="line">                .title(&quot;网盘项目 API&quot;)</span><br><span class="line">                .description(&quot;基于springboot + vue 框架开发的Web文件系统，旨在为用户提供一个简单、方便的文件存储方案，能够以完善的目录结构体系，对文件进行管理 。&quot;)</span><br><span class="line">                .version(&quot;1.0&quot;)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新启动后，查看效果，如下图：<br><img src="https://pic.imgdb.cn/item/63db9036ac6ef86016bbb523.png" alt="knife4j"></p>]]></content>
      
      
      <categories>
          
          <category> 学习相关 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>引入“盐值”机制进行密码加密</title>
      <link href="/2023/01/17/%E5%BC%95%E5%85%A5%E7%9B%90%E5%80%BC%E6%9C%BA%E5%88%B6%E8%BF%9B%E8%A1%8C%E5%AF%86%E7%A0%81%E5%8A%A0%E5%AF%86/"/>
      <url>/2023/01/17/%E5%BC%95%E5%85%A5%E7%9B%90%E5%80%BC%E6%9C%BA%E5%88%B6%E8%BF%9B%E8%A1%8C%E5%AF%86%E7%A0%81%E5%8A%A0%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<p>今天做毕设时，发现参考的项目在实现登录注册功能这一块引入了“盐值”这一属性，一脸懵逼。只联想到知乎貌似也有个“盐值”这种东西，只不过那个更类似于信誉值，和密码这一块扯不上联系。</p><p>以前做的项目密码都是直接采用的md5加密，md5可以将任意字符串，通过不可逆的字符串变换算法，生成一个唯一的 MD5 信息摘要，所以心想应该是很安全的，为啥要多此一举呢。于是在网上查了查相关信息。</p><p>好吧，果然没那么简单，md5加密是<strong>非安全的</strong>。</p><h2 id="1-彩虹表"><a href="#1-彩虹表" class="headerlink" title="1.彩虹表"></a>1.彩虹表</h2><p>MD5 之所以说它是不安全的，是因为每一个原始密码都会生成一个对应的固定密码，也就是说一个字符串生成的 MD5 值是永远不变的。这样的话，虽然它是不可逆的，但可以被穷举，而穷举的“产品”就叫做彩虹表。</p><p><strong>简单来说，彩虹表就是一个很大的，用于存放穷举对应值的数据表。如果有了这张表之后，那么我就可以通过 MD5 的密文直接查到原始密码了。</strong></p><h2 id="2-盐值机制"><a href="#2-盐值机制" class="headerlink" title="2.盐值机制"></a>2.盐值机制</h2><p>想要解决以上问题，我们需要引入“加盐”机制。</p><p><strong>盐（Salt）：在密码学中，是指通过在密码任意固定位置插入特定的字符串，让散列后的结果和使用原始密码的散列结果不相符，这种过程称之为“加盐”。</strong></p><p>也就是说在原密码上加一段随机字符串，形成的新密码进行加密后，即使你能解析出这段新密码，你也不知道加的随机字符串是多少，也就不能知道真正的原密码。而我们可以在拿到任一密码后对其加上相同的随机字符串，也就是“盐值”，再进行加密，判断形成的值和数据库内的密码是否相同来判断密码是否正确。</p><h2 id="3-实现代码"><a href="#3-实现代码" class="headerlink" title="3.实现代码"></a>3.实现代码</h2><p>我项目中的代码给用户实体增加了”salt”这一属性用以保存“盐值”,具体代码如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public RestResult&lt;String&gt; registerUser(User user) &#123;</span><br><span class="line">    //判断验证码</span><br><span class="line">    String telephone = user.getTelephone();</span><br><span class="line">    String password = user.getPassword();</span><br><span class="line"></span><br><span class="line">    if (!StringUtils.hasLength(telephone) || !StringUtils.hasLength(password))&#123;</span><br><span class="line">        return RestResult.fail().message(&quot;手机号或密码不能为空！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (isTelePhoneExit(telephone))&#123;</span><br><span class="line">        return RestResult.fail().message(&quot;手机号已存在！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  //随机盐值UUID</span><br><span class="line">    String salt = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;).substring(15);</span><br><span class="line">    String passwordAndSalt = password + salt;</span><br><span class="line">    // 密码=md5(随机盐值+密码)</span><br><span class="line">    String newPassword = DigestUtils.md5DigestAsHex(passwordAndSalt.getBytes());</span><br><span class="line"></span><br><span class="line">    user.setSalt(salt);</span><br><span class="line"></span><br><span class="line">    user.setPassword(newPassword);</span><br><span class="line">    user.setRegisterTime(DateUtil.getCurrentTime());</span><br><span class="line">    int result = userMapper.insert(user);</span><br><span class="line"></span><br><span class="line">    if (result == 1) &#123;</span><br><span class="line">        return RestResult.success();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return RestResult.fail().message(&quot;注册用户失败，请检查输入信息！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在网上找到了更好的实现方法，可以不用设置salt这一属性，直接将盐值的真实值附加在盐值与原密码加密后的值中，使用一个间隔符进行隔开，形成新密码。解密时通过分隔符提取出盐值，然后用传过来的任一密码加上盐值进行加密，判断加密后的值是否与分割符后的另一值相同，相同则密码正确，不同则密码错误。</p><p>具体代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.util.DigestUtils;</span><br><span class="line">import org.springframework.util.StringUtils;</span><br><span class="line">import java.util.UUID;</span><br><span class="line"></span><br><span class="line">public class PasswordUtil &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 加密（加盐处理）</span><br><span class="line">     * @param password 待加密密码（需要加密的密码）</span><br><span class="line">     * @return 加密后的密码</span><br><span class="line">     */</span><br><span class="line">    public static String encrypt(String password) &#123;</span><br><span class="line">        // 随机盐值 UUID</span><br><span class="line">        String salt = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;);</span><br><span class="line">        // 密码=md5(随机盐值+密码)</span><br><span class="line">        String finalPassword = DigestUtils.md5DigestAsHex((salt + password).getBytes());</span><br><span class="line">        return salt + &quot;$&quot; + finalPassword;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 解密</span><br><span class="line">     * @param password       要验证的密码（未加密）</span><br><span class="line">     * @param securePassword 数据库中的加了盐值的密码</span><br><span class="line">     * @return 对比结果 true OR false</span><br><span class="line">     */</span><br><span class="line">    public static boolean decrypt(String password, String securePassword) &#123;</span><br><span class="line">        boolean result = false;</span><br><span class="line">        if (StringUtils.hasLength(password) &amp;&amp; StringUtils.hasLength(securePassword)) &#123;</span><br><span class="line">            if (securePassword.length() == 65 &amp;&amp; securePassword.contains(&quot;$&quot;)) &#123;</span><br><span class="line">                String[] securePasswordArr = securePassword.split(&quot;\\$&quot;);</span><br><span class="line">                // 盐值</span><br><span class="line">                String slat = securePasswordArr[0];</span><br><span class="line">                String finalPassword = securePasswordArr[1];</span><br><span class="line">                // 使用同样的加密算法和随机盐值生成最终加密的密码</span><br><span class="line">                password = DigestUtils.md5DigestAsHex((slat + password).getBytes());</span><br><span class="line">                if (finalPassword.equals(password)) &#123;</span><br><span class="line">                    result = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>曾想过如果是可以看到数据库的人在知道加密后的密码和盐值的情况下是否能还原出原密码，仔细想想还是不行，md5加密前后的字符串是一一对应的，即使先将盐值加密也无法对盐值与密码加密后的字符串有任何用途。</p>]]></content>
      
      
      <categories>
          
          <category> 学习相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 加密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法的学习及使用</title>
      <link href="/2022/11/28/Markdown%E8%AF%AD%E6%B3%95%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/11/28/Markdown%E8%AF%AD%E6%B3%95%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本篇文章参考于: <a href="https://www.runoob.com/markdown/md-tutorial.html">https://www.runoob.com/markdown/md-tutorial.html</a></p></blockquote><h1 id="1-标题"><a href="#1-标题" class="headerlink" title="1. 标题"></a>1. 标题</h1><blockquote><p># 一级标题<br>## 二级标题<br>### 三级标题<br>#### 四级标题<br>##### 五级标题<br>###### 六级标题</p></blockquote><p>效果显示如下:</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h1 id="2-段落格式"><a href="#2-段落格式" class="headerlink" title="2. 段落格式"></a>2. 段落格式</h1><h2 id="2-1-段落的换行"><a href="#2-1-段落的换行" class="headerlink" title="2.1 段落的换行"></a>2.1 段落的换行</h2><p>方式一，在段落的换行时使用两个以上空格加上回车。<br>这是方式一的第二段。</p><p>方式二，在段落后面使用一个空行来表示重新开始一个段落</p><p>这是方式二的第二段</p><h2 id="2-2-字体"><a href="#2-2-字体" class="headerlink" title="2.2 字体"></a>2.2 字体</h2><blockquote><p>*斜体文本*<br>*<em>粗体文本</em>*<br>**<em>粗斜体文本</em>**</p></blockquote><p>效果显示如下:</p><p><em>斜体文字</em><br><strong>粗体文字</strong><br><em><strong>粗斜体文字</strong></em></p><h2 id="2-3-分割线"><a href="#2-3-分割线" class="headerlink" title="2.3 分割线"></a>2.3 分割线</h2><blockquote><p>***</p></blockquote><p>效果显示如下:</p><hr><h2 id="2-4-删除线"><a href="#2-4-删除线" class="headerlink" title="2.4 删除线"></a>2.4 删除线</h2><blockquote><p>~~这是删除线~~</p></blockquote><p>效果显示如下:</p><p><del>这是删除线</del></p><h2 id="2-5-下划线"><a href="#2-5-下划线" class="headerlink" title="2.5 下划线"></a>2.5 下划线</h2><blockquote><p>&lt;u&gt;这是下划线&lt;&#x2F;u&gt;</p></blockquote><p>效果显示如下:</p><p><u>这是下划线</u></p><h2 id="2-6-脚注"><a href="#2-6-脚注" class="headerlink" title="2.6 脚注"></a>2.6 脚注</h2><p>创建脚注格式类似这样[^脚注]。<br>[^脚注]:这就是脚注</p><h1 id="3-列表"><a href="#3-列表" class="headerlink" title="3. 列表"></a>3. 列表</h1><blockquote><p>* 无序列表1<br>* 无序列表2<br>* 无序列表3</p></blockquote><blockquote><ol><li>有序列表1</li><li>有序列表2</li><li>有序列表3</li></ol></blockquote><p>效果显示如下:</p><ul><li>无序列表1</li><li>无序列表2</li><li>无序列表3</li></ul><ol><li>有序列表1</li><li>有序列表2</li><li>有序列表3</li></ol><h2 id="3-1-列表嵌套"><a href="#3-1-列表嵌套" class="headerlink" title="3.1 列表嵌套"></a>3.1 列表嵌套</h2><p>1.第一项:<br>  - 第一项嵌套的第一个元素<br>  - 第一项嵌套的第二个元素<br>2.第二项:<br>  - 第二项嵌套的第一个元素<br>  - 第二项嵌套的第二个元素</p><p>效果显示如下:</p><ol><li>第一项:</li></ol><ul><li>第一项嵌套的第一个元素</li><li>第一项嵌套的第二个元素</li></ul><ol start="2"><li>第二项:</li></ol><ul><li>第二项嵌套的第一个元素</li><li>第二项嵌套的第二个元素</li></ul><h1 id="4-区块"><a href="#4-区块" class="headerlink" title="4. 区块"></a>4. 区块</h1><blockquote><p>&gt; 区块引用<br>&gt; 换行后前面也要加&gt;</p></blockquote><blockquote><p>&gt; 区块是可以嵌套的，最外层<br>&gt;&gt; 第一层嵌套<br>&gt;&gt;&gt; 第二层嵌套</p></blockquote><blockquote><p>&gt; 区块中使用列表<br>&gt; 1. 第一项<br>&gt; 2. 第二项<br>&gt; * 第一项<br>&gt; * 第二项</p></blockquote><blockquote><p>* 列表中使用区块，第一项<br>\  &gt; 区块1<br>\  &gt; 区块2<br>* 第二项<br>\  &gt; 区块1</p></blockquote><p>效果显示如下:</p><blockquote><p>区块引用<br>换行后前面也要加&gt;</p></blockquote><blockquote><p>区块是可以嵌套的，最外层</p><blockquote><p>第一层嵌套</p><blockquote><p>第二层嵌套</p></blockquote></blockquote></blockquote><blockquote><p>区块中使用列表</p><ol><li>第一项</li><li>第二项</li></ol><ul><li>第一项</li><li>第二项</li></ul></blockquote><ul><li>列表中使用区块，第一项<blockquote><p>区块1<br>区块2</p></blockquote></li><li>第二项<blockquote><p>区块1</p></blockquote></li></ul><h1 id="5-代码"><a href="#5-代码" class="headerlink" title="5. 代码"></a>5. 代码</h1><blockquote><p>`printf()&#96;函数</p></blockquote><p>效果显示如下:</p><p><code>printf()</code>函数</p><h2 id="5-1-代码区块"><a href="#5-1-代码区块" class="headerlink" title="5.1 代码区块"></a>5.1 代码区块</h2><blockquote><p>`&#96;&#96;<br>public static void main(String[] args){<br> System.out.println(“代码块可用`&#96;&#96;来包裹&gt;”);<br>}<br>`&#96;&#96;</p></blockquote><p>效果显示如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">  System.out.println(&quot;代码块可用```来包裹&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6-链接"><a href="#6-链接" class="headerlink" title="6. 链接"></a>6. 链接</h1><blockquote><ol><li>[链接名称](<a href="https://www.runoob.com/">https://www.runoob.com</a>)</li><li><a href="https://www.runoob.com/">https://www.runoob.com</a></li></ol></blockquote><p>效果显示如下:</p><ol><li><a href="https://www.runoob.com/">链接名称</a></li><li><a href="https://www.runoob.com/">https://www.runoob.com</a></li></ol><h1 id="7-图片"><a href="#7-图片" class="headerlink" title="7. 图片"></a>7. 图片</h1><blockquote><p>![图片的替代文字](<a href="http://static.runoob.com/images/runoob-logo.png">http://static.runoob.com/images/runoob-logo.png</a>)</p><p>![图片的替代文字](<a href="http://static.runoob.com/images/runoob-logo.png">http://static.runoob.com/images/runoob-logo.png</a> “可选标题”)  </p></blockquote><p>显示结果如下:</p><p><img src="http://static.runoob.com/images/runoob-logo.png" alt="图片的替代文字" title="可选标题"><br>可以对图片网址使用变量:</p><blockquote><p>这个链接用 1 作为网址变量 [RUNOOB][1].<br>然后在文档的结尾为变量赋值（网址）<br>[1]: <a href="http://static.runoob.com/images/runoob-logo.png">http://static.runoob.com/images/runoob-logo.png</a></p></blockquote><p>Markdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 &lt;img&gt; 标签。</p><blockquote><p>&lt;img decoding&#x3D;”async” src&#x3D;”<a href="http://static.runoob.com/images/runoob-logo.png&quot;">http://static.runoob.com/images/runoob-logo.png&quot;</a> width&#x3D;”50%”&gt;</p></blockquote><h1 id="8-表格"><a href="#8-表格" class="headerlink" title="8. 表格"></a>8. 表格</h1><blockquote><p>|  表头   | 表头  |<br>|  —-  | —-  |<br>| 单元格  | 单元格 |<br>| 单元格  | 单元格 |</p></blockquote><blockquote><p>| 左对齐 | 右对齐 | 居中对齐 |<br>| :—–| —-: | :—-: |<br>| 单元格 | 单元格 | 单元格 |<br>| 单元格 | 单元格 | 单元格 |</p></blockquote><p>显示结果如下:</p><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table><table><thead><tr><th align="left">左对齐</th><th align="right">右对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 博客搭建相关 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* 页脚与头图透明 */#footer {    background: transparent !important;  }  #page-header {    background: transparent !important;  }    /* 白天模式遮罩透明 */  #footer::before {    background: transparent !important;  }  #page-header::before {    background: transparent !important;  }    /* 夜间模式遮罩透明 */  [data-theme="dark"] #footer::before {    background: transparent !important;  }  [data-theme="dark"] #page-header::before {    background: transparent !important;  }]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友链</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>音乐</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[    <div id="aplayer-RYiDSkwb" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="7782065613" data-server="netease" data-type="playlist/song" data-mode="circulation" data-autoplay="true" data-mutex="false" data-listmaxheight="400px" data-preload="none" data-theme="#ad7a86"    ></div>]]></content>
      
    </entry>
    
    
  
</search>
