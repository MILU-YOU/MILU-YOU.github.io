<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Swagger3的集成及使用</title>
      <link href="/2023/01/20/Swagger3%E7%9A%84%E9%9B%86%E6%88%90%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/01/20/Swagger3%E7%9A%84%E9%9B%86%E6%88%90%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Swagger相关介绍"><a href="#1-Swagger相关介绍" class="headerlink" title="1.Swagger相关介绍"></a>1.Swagger相关介绍</h2><p>前后端分离的项目，接口文档的存在十分重要。与手动编写接口文档不同，<strong>swagger是一个用于生成、描述和调用 RESTful 接口的 Web 服务。</strong> 通俗来讲就是可以自动生成接口文档并测试调用相关接口。</p><p>Swagger2已经在17年停止维护了，取而代之的是 sagger3，与 swagger2 相比新版的swagger3 配置更少，使用更加方便。</p><p>如果想要将 Swagger 文档集成到 Spring 中，目前有两个开源项目可供开发者选择，一个是 SpringFox，另一个是 SpringDoc，这两个项目都是由 Spring 社区来维护的，在 Swagger 2.0 时代，SpringFox 是主流，但是随着 Swagger 3.0 版本发布之后，SpringDoc 对最新版本的兼容性更好，而且 SpringDoc 支持 Swagger 页面 Oauth2 登录，因此使用 SpringDoc 是更好的选择。</p><h2 id="2-集成步骤"><a href="#2-集成步骤" class="headerlink" title="2.集成步骤"></a>2.集成步骤</h2><h3 id="①向pom-xml文件中添加如下依赖"><a href="#①向pom-xml文件中添加如下依赖" class="headerlink" title="①向pom.xml文件中添加如下依赖"></a>①向pom.xml文件中添加如下依赖</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springdoc&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springdoc-openapi-ui&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.5.4&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="②书写配置类"><a href="#②书写配置类" class="headerlink" title="②书写配置类"></a>②书写配置类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class OpenApiConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public OpenAPI qiwenFileOpenAPI() &#123;</span><br><span class="line">        return new OpenAPI()</span><br><span class="line">                .info(new Info().title(&quot;网盘项目 API&quot;)</span><br><span class="line">                        .description(&quot;基于springboot + vue 框架开发的Web文件系统，旨在为用户提供一个简单、方便的文件存储方案，能够以完善的目录结构体系，对文件进行管理 。&quot;)</span><br><span class="line">                        .version(&quot;v1.0.0&quot;)</span><br><span class="line">                        .license(new License().name(&quot;MIT&quot;).url(&quot;http://springdoc.org&quot;)))</span><br><span class="line">                .externalDocs(new ExternalDocumentation()</span><br><span class="line">                        .description(&quot;网盘gitee地址&quot;)</span><br><span class="line">                        .url(&quot;https://www.gitee.com/qiwen-cloud/qiwen-file&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="③在代码中添加相应接口的注解描述"><a href="#③在代码中添加相应接口的注解描述" class="headerlink" title="③在代码中添加相应接口的注解描述"></a>③在代码中添加相应接口的注解描述</h3><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Tag(name = &quot;user&quot;, description = &quot;该接口为用户接口，主要做用户登录，注册和校验token&quot;)</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/user&quot;)</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    @Operation(summary = &quot;用户注册&quot;, description = &quot;注册账号&quot;, tags = &#123;&quot;user&quot;&#125;)</span><br><span class="line">    @PostMapping(value = &quot;/register&quot;)</span><br><span class="line">    public RestResult&lt;String&gt; addUser(@RequestBody RegisterDTO registerDTO) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="④访问Swagger"><a href="#④访问Swagger" class="headerlink" title="④访问Swagger"></a>④访问Swagger</h3><p>启动项目后，在浏览器中访问如下地址即可:</p><blockquote><p>localhost:8080&#x2F;swagger-ui&#x2F;</p></blockquote><p>显示效果如下:<br><img src="https://pic.imgdb.cn/item/63db903aac6ef86016bbbe25.png" alt="swagger3"></p><h2 id="3-注解介绍"><a href="#3-注解介绍" class="headerlink" title="3.注解介绍"></a>3.注解介绍</h2><p><strong>@Tag注解</strong><br>该注解可以用在类或方法上，当作用在方法是用来定义单个操作，当作用在类上代表所有操作。</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>name</td><td>标签名</td></tr><tr><td>description</td><td>这里可以做一个简短的描述</td></tr><tr><td>externalDocs</td><td>添加一个扩展文档</td></tr><tr><td>extensions</td><td>可选的扩展列表</td></tr></tbody></table><p><strong>@Operation注解</strong><br>该注解可用于将资源方法定义为 OpenAPI 操作，在该注解中也可以定义该操作的其他属性。</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>method</td><td>HTTP 请求方法</td></tr><tr><td>tags</td><td>按照资源对操作进行逻辑分组</td></tr><tr><td>summary</td><td>提供此操作的简要说明</td></tr><tr><td>description</td><td>对操作的详细描述</td></tr><tr><td>requestBody</td><td>与操作关联的请求报文</td></tr><tr><td>parameters</td><td>一个可选的参数数组</td></tr><tr><td>responses</td><td>执行此操作返回的可能响应的列表</td></tr><tr><td>deprecated</td><td>允许将操作标记为已弃用</td></tr><tr><td>security</td><td>可用于此操作的安全机制的声明</td></tr></tbody></table><p><strong>@Schema注解</strong><br>该注解用来定义模型，主要用来定义模型类及模型的属性，请求和响应的内容、报文头等。</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>not</td><td>提供用于禁止匹配属性的 java 类</td></tr><tr><td>name</td><td>用于描述模型类或属性的名称</td></tr><tr><td>title</td><td>用于描述模型类的标题</td></tr><tr><td>maximum</td><td>设置属性的最大数值</td></tr><tr><td>minimum</td><td>设置属性的最小数值</td></tr><tr><td>maxLength</td><td>设置字符串值的最大长度</td></tr><tr><td>minLength</td><td>设置字符串值的最大小度</td></tr><tr><td>pattern</td><td>值必须满足的模式</td></tr><tr><td>required</td><td>是否必需输入</td></tr><tr><td>description</td><td>描述</td></tr><tr><td>nullable</td><td>如果为 true 则可能为 null</td></tr><tr><td>example</td><td>使用示例</td></tr></tbody></table><hr><p><strong>swagger3与swagger2的注解对应关系为:</strong></p><table><thead><tr><th>swagger2</th><th>OpenAPI 3</th><th>注解位置</th></tr></thead><tbody><tr><td>@Api</td><td>@Tag(name &#x3D; “接口类描述”)</td><td>Controller 类上</td></tr><tr><td>@ApiOperation</td><td>@Operation(summary &#x3D;“接口方法描述”)</td><td>Controller 方法上</td></tr><tr><td>@ApiImplicitParams</td><td>@Parameters</td><td>Controller 方法上</td></tr><tr><td>@ApiImplicitParam</td><td>@Parameter(description&#x3D;“参数描述”)</td><td>Controller 方法上 @Parameters 里</td></tr><tr><td>@ApiParam</td><td>@Parameter(description&#x3D;“参数描述”)</td><td>Controller 方法的参数上</td></tr><tr><td>@ApiIgnore</td><td>@Parameter(hidden &#x3D; true) 或 @Operation(hidden &#x3D; true) 或 @Hidden</td><td>-</td></tr><tr><td>@ApiModel</td><td>@Schema</td><td>DTO类上</td></tr><tr><td>@ApiModelProperty</td><td>@Schema</td><td>DTO属性上</td></tr></tbody></table><p>至此整个文档在开发过程已经满足日常使用的要求，但是整体文档风格及排版不太符合大多数人的视觉体验，甚至有人觉得它丑，这个因人而异，因此下面将介绍另一款工具 knife4j，来美化该文档。</p><h2 id="4-集成knife4j美化文档"><a href="#4-集成knife4j美化文档" class="headerlink" title="4.集成knife4j美化文档"></a>4.集成knife4j美化文档</h2><p>knife4j 在最新版本已经基本完全兼容了 springdoc-openapi-ui，因此在替换的时候将依赖替换掉就可以了，打开 pom.xml 文件，删除掉之前的 springdoc-openapi-ui 依赖，添加如下依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.0.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>替换完成之后，重新启动项目，在地址栏之后添加 <strong>&#x2F;doc.html</strong> 即可访问文档。</p><p>然后在配置文件中将先前的配置类改为如下配置完善文档描述信息:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class OpenApiConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean(value = &quot;indexApi&quot;)</span><br><span class="line">    public Docket indexApi() &#123;</span><br><span class="line">        return new Docket(DocumentationType.OAS_30)</span><br><span class="line">                .groupName(&quot;网站前端接口分组&quot;).apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(&quot;team.zlg.file.controller&quot;))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ApiInfo apiInfo() &#123;</span><br><span class="line">        return new ApiInfoBuilder()</span><br><span class="line">                .title(&quot;网盘项目 API&quot;)</span><br><span class="line">                .description(&quot;基于springboot + vue 框架开发的Web文件系统，旨在为用户提供一个简单、方便的文件存储方案，能够以完善的目录结构体系，对文件进行管理 。&quot;)</span><br><span class="line">                .version(&quot;1.0&quot;)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新启动后，查看效果，如下图：<br><img src="https://pic.imgdb.cn/item/63db9036ac6ef86016bbb523.png" alt="knife4j"></p>]]></content>
      
      
      <categories>
          
          <category> 学习相关 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>引入“盐值”机制进行密码加密</title>
      <link href="/2023/01/17/%E5%BC%95%E5%85%A5%E7%9B%90%E5%80%BC%E6%9C%BA%E5%88%B6%E8%BF%9B%E8%A1%8C%E5%AF%86%E7%A0%81%E5%8A%A0%E5%AF%86/"/>
      <url>/2023/01/17/%E5%BC%95%E5%85%A5%E7%9B%90%E5%80%BC%E6%9C%BA%E5%88%B6%E8%BF%9B%E8%A1%8C%E5%AF%86%E7%A0%81%E5%8A%A0%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<p>今天做毕设时，发现参考的项目在实现登录注册功能这一块引入了“盐值”这一属性，一脸懵逼。只联想到知乎貌似也有个“盐值”这种东西，只不过那个更类似于信誉值，和密码这一块扯不上联系。</p><p>以前做的项目密码都是直接采用的md5加密，md5可以将任意字符串，通过不可逆的字符串变换算法，生成一个唯一的 MD5 信息摘要，所以心想应该是很安全的，为啥要多此一举呢。于是在网上查了查相关信息。</p><p>好吧，果然没那么简单，md5加密是<strong>非安全的</strong>。</p><h2 id="1-彩虹表"><a href="#1-彩虹表" class="headerlink" title="1.彩虹表"></a>1.彩虹表</h2><p>MD5 之所以说它是不安全的，是因为每一个原始密码都会生成一个对应的固定密码，也就是说一个字符串生成的 MD5 值是永远不变的。这样的话，虽然它是不可逆的，但可以被穷举，而穷举的“产品”就叫做彩虹表。</p><p><strong>简单来说，彩虹表就是一个很大的，用于存放穷举对应值的数据表。如果有了这张表之后，那么我就可以通过 MD5 的密文直接查到原始密码了。</strong></p><h2 id="2-盐值机制"><a href="#2-盐值机制" class="headerlink" title="2.盐值机制"></a>2.盐值机制</h2><p>想要解决以上问题，我们需要引入“加盐”机制。</p><p><strong>盐（Salt）：在密码学中，是指通过在密码任意固定位置插入特定的字符串，让散列后的结果和使用原始密码的散列结果不相符，这种过程称之为“加盐”。</strong></p><p>也就是说在原密码上加一段随机字符串，形成的新密码进行加密后，即使你能解析出这段新密码，你也不知道加的随机字符串是多少，也就不能知道真正的原密码。而我们可以在拿到任一密码后对其加上相同的随机字符串，也就是“盐值”，再进行加密，判断形成的值和数据库内的密码是否相同来判断密码是否正确。</p><h2 id="3-实现代码"><a href="#3-实现代码" class="headerlink" title="3.实现代码"></a>3.实现代码</h2><p>我项目中的代码给用户实体增加了”salt”这一属性用以保存“盐值”,具体代码如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public RestResult&lt;String&gt; registerUser(User user) &#123;</span><br><span class="line">    //判断验证码</span><br><span class="line">    String telephone = user.getTelephone();</span><br><span class="line">    String password = user.getPassword();</span><br><span class="line"></span><br><span class="line">    if (!StringUtils.hasLength(telephone) || !StringUtils.hasLength(password))&#123;</span><br><span class="line">        return RestResult.fail().message(&quot;手机号或密码不能为空！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (isTelePhoneExit(telephone))&#123;</span><br><span class="line">        return RestResult.fail().message(&quot;手机号已存在！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  //随机盐值UUID</span><br><span class="line">    String salt = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;).substring(15);</span><br><span class="line">    String passwordAndSalt = password + salt;</span><br><span class="line">    // 密码=md5(随机盐值+密码)</span><br><span class="line">    String newPassword = DigestUtils.md5DigestAsHex(passwordAndSalt.getBytes());</span><br><span class="line"></span><br><span class="line">    user.setSalt(salt);</span><br><span class="line"></span><br><span class="line">    user.setPassword(newPassword);</span><br><span class="line">    user.setRegisterTime(DateUtil.getCurrentTime());</span><br><span class="line">    int result = userMapper.insert(user);</span><br><span class="line"></span><br><span class="line">    if (result == 1) &#123;</span><br><span class="line">        return RestResult.success();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return RestResult.fail().message(&quot;注册用户失败，请检查输入信息！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在网上找到了更好的实现方法，可以不用设置salt这一属性，直接将盐值的真实值附加在盐值与原密码加密后的值中，使用一个间隔符进行隔开，形成新密码。解密时通过分隔符提取出盐值，然后用传过来的任一密码加上盐值进行加密，判断加密后的值是否与分割符后的另一值相同，相同则密码正确，不同则密码错误。</p><p>具体代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.util.DigestUtils;</span><br><span class="line">import org.springframework.util.StringUtils;</span><br><span class="line">import java.util.UUID;</span><br><span class="line"></span><br><span class="line">public class PasswordUtil &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 加密（加盐处理）</span><br><span class="line">     * @param password 待加密密码（需要加密的密码）</span><br><span class="line">     * @return 加密后的密码</span><br><span class="line">     */</span><br><span class="line">    public static String encrypt(String password) &#123;</span><br><span class="line">        // 随机盐值 UUID</span><br><span class="line">        String salt = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;);</span><br><span class="line">        // 密码=md5(随机盐值+密码)</span><br><span class="line">        String finalPassword = DigestUtils.md5DigestAsHex((salt + password).getBytes());</span><br><span class="line">        return salt + &quot;$&quot; + finalPassword;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 解密</span><br><span class="line">     * @param password       要验证的密码（未加密）</span><br><span class="line">     * @param securePassword 数据库中的加了盐值的密码</span><br><span class="line">     * @return 对比结果 true OR false</span><br><span class="line">     */</span><br><span class="line">    public static boolean decrypt(String password, String securePassword) &#123;</span><br><span class="line">        boolean result = false;</span><br><span class="line">        if (StringUtils.hasLength(password) &amp;&amp; StringUtils.hasLength(securePassword)) &#123;</span><br><span class="line">            if (securePassword.length() == 65 &amp;&amp; securePassword.contains(&quot;$&quot;)) &#123;</span><br><span class="line">                String[] securePasswordArr = securePassword.split(&quot;\\$&quot;);</span><br><span class="line">                // 盐值</span><br><span class="line">                String slat = securePasswordArr[0];</span><br><span class="line">                String finalPassword = securePasswordArr[1];</span><br><span class="line">                // 使用同样的加密算法和随机盐值生成最终加密的密码</span><br><span class="line">                password = DigestUtils.md5DigestAsHex((slat + password).getBytes());</span><br><span class="line">                if (finalPassword.equals(password)) &#123;</span><br><span class="line">                    result = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>曾想过如果是可以看到数据库的人在知道加密后的密码和盐值的情况下是否能还原出原密码，仔细想想还是不行，md5加密前后的字符串是一一对应的，即使先将盐值加密也无法对盐值与密码加密后的字符串有任何用途。</p>]]></content>
      
      
      <categories>
          
          <category> 学习相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 加密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法的学习及使用</title>
      <link href="/2022/11/28/Markdown%E8%AF%AD%E6%B3%95%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/11/28/Markdown%E8%AF%AD%E6%B3%95%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本篇文章参考于: <a href="https://www.runoob.com/markdown/md-tutorial.html">https://www.runoob.com/markdown/md-tutorial.html</a></p></blockquote><h1 id="1-标题"><a href="#1-标题" class="headerlink" title="1. 标题"></a>1. 标题</h1><blockquote><p># 一级标题<br>## 二级标题<br>### 三级标题<br>#### 四级标题<br>##### 五级标题<br>###### 六级标题</p></blockquote><p>效果显示如下:</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h1 id="2-段落格式"><a href="#2-段落格式" class="headerlink" title="2. 段落格式"></a>2. 段落格式</h1><h2 id="2-1-段落的换行"><a href="#2-1-段落的换行" class="headerlink" title="2.1 段落的换行"></a>2.1 段落的换行</h2><p>方式一，在段落的换行时使用两个以上空格加上回车。<br>这是方式一的第二段。</p><p>方式二，在段落后面使用一个空行来表示重新开始一个段落</p><p>这是方式二的第二段</p><h2 id="2-2-字体"><a href="#2-2-字体" class="headerlink" title="2.2 字体"></a>2.2 字体</h2><blockquote><p>*斜体文本*<br>*<em>粗体文本</em>*<br>**<em>粗斜体文本</em>**</p></blockquote><p>效果显示如下:</p><p><em>斜体文字</em><br><strong>粗体文字</strong><br><em><strong>粗斜体文字</strong></em></p><h2 id="2-3-分割线"><a href="#2-3-分割线" class="headerlink" title="2.3 分割线"></a>2.3 分割线</h2><blockquote><p>***</p></blockquote><p>效果显示如下:</p><hr><h2 id="2-4-删除线"><a href="#2-4-删除线" class="headerlink" title="2.4 删除线"></a>2.4 删除线</h2><blockquote><p>~~这是删除线~~</p></blockquote><p>效果显示如下:</p><p><del>这是删除线</del></p><h2 id="2-5-下划线"><a href="#2-5-下划线" class="headerlink" title="2.5 下划线"></a>2.5 下划线</h2><blockquote><p>&lt;u&gt;这是下划线&lt;&#x2F;u&gt;</p></blockquote><p>效果显示如下:</p><p><u>这是下划线</u></p><h2 id="2-6-脚注"><a href="#2-6-脚注" class="headerlink" title="2.6 脚注"></a>2.6 脚注</h2><p>创建脚注格式类似这样[^脚注]。<br>[^脚注]:这就是脚注</p><h1 id="3-列表"><a href="#3-列表" class="headerlink" title="3. 列表"></a>3. 列表</h1><blockquote><p>* 无序列表1<br>* 无序列表2<br>* 无序列表3</p></blockquote><blockquote><p>1.有序列表1<br>2.有序列表2<br>3.有序列表3</p></blockquote><p>效果显示如下:</p><ul><li>无序列表1</li><li>无序列表2</li><li>无序列表3</li></ul><ol><li>有序列表1</li><li>有序列表2</li><li>有序列表3</li></ol><h2 id="3-1-列表嵌套"><a href="#3-1-列表嵌套" class="headerlink" title="3.1 列表嵌套"></a>3.1 列表嵌套</h2><p>1.第一项:<br>  - 第一项嵌套的第一个元素<br>  - 第一项嵌套的第二个元素<br>2.第二项:<br>  - 第二项嵌套的第一个元素<br>  - 第二项嵌套的第二个元素</p><p>效果显示如下:</p><ol><li>第一项:</li></ol><ul><li>第一项嵌套的第一个元素</li><li>第一项嵌套的第二个元素</li></ul><ol start="2"><li>第二项:</li></ol><ul><li>第二项嵌套的第一个元素</li><li>第二项嵌套的第二个元素</li></ul><h1 id="4-区块"><a href="#4-区块" class="headerlink" title="4. 区块"></a>4. 区块</h1><blockquote><p>&gt; 区块引用<br>&gt; 换行后前面也要加&gt;</p></blockquote><blockquote><p>&gt; 区块是可以嵌套的，最外层<br>&gt;&gt; 第一层嵌套<br>&gt;&gt;&gt; 第二层嵌套</p></blockquote><blockquote><p>&gt; 区块中使用列表<br>&gt; 1. 第一项<br>&gt; 2. 第二项<br>&gt; * 第一项<br>&gt; * 第二项</p></blockquote><blockquote><p>* 列表中使用区块，第一项<br>\  &gt; 区块1<br>\  &gt; 区块2<br>* 第二项<br>\  &gt; 区块1</p></blockquote><p>效果显示如下:</p><blockquote><p>区块引用<br>换行后前面也要加&gt;</p></blockquote><blockquote><p>区块是可以嵌套的，最外层</p><blockquote><p>第一层嵌套</p><blockquote><p>第二层嵌套</p></blockquote></blockquote></blockquote><blockquote><p>区块中使用列表</p><ol><li>第一项</li><li>第二项</li></ol><ul><li>第一项</li><li>第二项</li></ul></blockquote><ul><li>列表中使用区块，第一项<blockquote><p>区块1<br>区块2</p></blockquote></li><li>第二项<blockquote><p>区块1</p></blockquote></li></ul><h1 id="5-代码"><a href="#5-代码" class="headerlink" title="5. 代码"></a>5. 代码</h1><blockquote><p>`printf()&#96;函数</p></blockquote><p>效果显示如下:</p><p><code>printf()</code>函数</p><h2 id="5-1-代码区块"><a href="#5-1-代码区块" class="headerlink" title="5.1 代码区块"></a>5.1 代码区块</h2><blockquote><p>`&#96;&#96;<br>public static void main(String[] args){<br> System.out.println(“代码块可用`&#96;&#96;来包裹&gt;”);<br>}<br>`&#96;&#96;</p></blockquote><p>效果显示如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">  System.out.println(&quot;代码块可用```来包裹&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6-链接"><a href="#6-链接" class="headerlink" title="6. 链接"></a>6. 链接</h1><blockquote><ol><li>[链接名称](<a href="https://www.runoob.com/">https://www.runoob.com</a>)</li><li><a href="https://www.runoob.com/">https://www.runoob.com</a></li></ol></blockquote><p>效果显示如下:</p><ol><li><a href="https://www.runoob.com/">链接名称</a></li><li><a href="https://www.runoob.com/">https://www.runoob.com</a></li></ol><h1 id="7-图片"><a href="#7-图片" class="headerlink" title="7. 图片"></a>7. 图片</h1><blockquote><p>![图片的替代文字](<a href="http://static.runoob.com/images/runoob-logo.png">http://static.runoob.com/images/runoob-logo.png</a>)</p><p>![图片的替代文字](<a href="http://static.runoob.com/images/runoob-logo.png">http://static.runoob.com/images/runoob-logo.png</a> “可选标题”)  </p></blockquote><p>显示结果如下:</p><p><img src="http://static.runoob.com/images/runoob-logo.png" alt="图片的替代文字" title="可选标题"><br>可以对图片网址使用变量:</p><blockquote><p>这个链接用 1 作为网址变量 [RUNOOB][1].<br>然后在文档的结尾为变量赋值（网址）<br>[1]: <a href="http://static.runoob.com/images/runoob-logo.png">http://static.runoob.com/images/runoob-logo.png</a></p></blockquote><p>Markdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 &lt;img&gt; 标签。</p><blockquote><p>&lt;img decoding&#x3D;”async” src&#x3D;”<a href="http://static.runoob.com/images/runoob-logo.png&quot;">http://static.runoob.com/images/runoob-logo.png&quot;</a> width&#x3D;”50%”&gt;</p></blockquote><h1 id="8-表格"><a href="#8-表格" class="headerlink" title="8. 表格"></a>8. 表格</h1><blockquote><p>|  表头   | 表头  |<br>|  —-  | —-  |<br>| 单元格  | 单元格 |<br>| 单元格  | 单元格 |</p></blockquote><blockquote><p>| 左对齐 | 右对齐 | 居中对齐 |<br>| :—–| —-: | :—-: |<br>| 单元格 | 单元格 | 单元格 |<br>| 单元格 | 单元格 | 单元格 |</p></blockquote><p>显示结果如下:</p><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table><table><thead><tr><th align="left">左对齐</th><th align="right">右对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 博客搭建相关 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* 页脚与头图透明 */#footer {    background: transparent !important;  }  #page-header {    background: transparent !important;  }    /* 白天模式遮罩透明 */  #footer::before {    background: transparent !important;  }  #page-header::before {    background: transparent !important;  }    /* 夜间模式遮罩透明 */  [data-theme="dark"] #footer::before {    background: transparent !important;  }  [data-theme="dark"] #page-header::before {    background: transparent !important;  }]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友链</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>音乐</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[    <div id="aplayer-RYiDSkwb" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="7782065613" data-server="netease" data-type="playlist/song" data-mode="circulation" data-autoplay="true" data-mutex="false" data-listmaxheight="400px" data-preload="none" data-theme="#ad7a86"    ></div>]]></content>
      
    </entry>
    
    
  
</search>
